## II. وابستگی‌ها
### صراحتا وابستگی‌ها رو مشخص کنید و آنها را ایزوله نگه دارید

بیشتر زبان‌های برنامه‌نویسی یک مکانیزم پکیج کردن یا بسته‌بندی کردن فراهم می‌کنند که برنامه‌نویسان بتوانند کتابخانه‌هاشون رو منتشر کنند، مثلا [CPAN](http://www.cpan.org/) برای زبان پرل یا [Rubygems](http://rubygems.org/) برای زبان روبی. کتابخانه‌هایی که توسط این سیستم پکیچینگ نصب می‌شوند می‌توانند به شکل system-wide باشند  (به نام "site packages" هم گفته می‌شود) یا اینکه به طور محدود فقط برای یک app بخصوص در دسترس باشد(به این حالت vendoring یا bundling می‌گویند)

** یک app مطابق قواعد ۱۲گانه هرگز نباید به صورت تلویجی به وجود یک پکیج(یا کتابخانه) system-wide متکی باشد **، در عوض باید وابستگی‌هایش را دقیقا و تماما به وسیله‌ی یک سند ا*علام وابستگی* مشخص کند، علاوه بر این، باید از یک ابزار مناسب جهت *ایزوله کردن وابستگی‌ها* هم استفاده کند تا اطمینان حاصل شود که هیچ وابستگی به طور ضمنی از سیستمی که app روی آن دپلوی شده تامین نمی‌شود.(م. مثلا تصور کنید که app روی یک سروری دپلوی شده و خوب کار میکنه اما روی سرور دوم بعد از دپلوی درست کار نمی‌کند چراکه در سرور اول علاوه بر وابستگی‌هایی که اعلام شده و نصب شده از یک سری وابستگی‌های تلویحی دیگه مثل پکیج‌های system-wide هم استفاده می‌کند این دقیقا مشکل درست ایزوله نکردن است)

**A twelve-factor app never relies on implicit existence of system-wide packages.**  It declares all dependencies, completely and exactly, via a *dependency declaration* manifest.  Furthermore, it uses a *dependency isolation* tool during execution to ensure that no implicit dependencies "leak in" from the surrounding system.  The full and explicit dependency specification is applied uniformly to both production and development.

For example, [Bundler](https://bundler.io/) for Ruby offers the `Gemfile` manifest format for dependency declaration and `bundle exec` for dependency isolation.  In Python there are two separate tools for these steps -- [Pip](http://www.pip-installer.org/en/latest/) is used for declaration and [Virtualenv](http://www.virtualenv.org/en/latest/) for isolation.  Even C has [Autoconf](http://www.gnu.org/s/autoconf/) for dependency declaration, and static linking can provide dependency isolation.  No matter what the toolchain, dependency declaration and isolation must always be used together -- only one or the other is not sufficient to satisfy twelve-factor.

One benefit of explicit dependency declaration is that it simplifies setup for developers new to the app.  The new developer can check out the app's codebase onto their development machine, requiring only the language runtime and dependency manager installed as prerequisites.  They will be able to set up everything needed to run the app's code with a deterministic *build command*.  For example, the build command for Ruby/Bundler is `bundle install`, while for Clojure/[Leiningen](https://github.com/technomancy/leiningen#readme) it is `lein deps`.

Twelve-factor apps also do not rely on the implicit existence of any system tools.  Examples include shelling out to ImageMagick or `curl`.  While these tools may exist on many or even most systems, there is no guarantee that they will exist on all systems where the app may run in the future, or whether the version found on a future system will be compatible with the app.  If the app needs to shell out to a system tool, that tool should be vendored into the app.
